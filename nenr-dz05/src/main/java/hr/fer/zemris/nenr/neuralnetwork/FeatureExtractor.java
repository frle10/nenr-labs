package hr.fer.zemris.nenr.neuralnetwork;

import java.awt.Point;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;

import hr.fer.zemris.nenr.datasetfactory.DoublePoint;
import hr.fer.zemris.nenr.datasetfactory.Gesture;

import static java.lang.Math.abs;
import static java.lang.Math.max;
import static hr.fer.zemris.nenr.datasetfactory.DoublePoint.*;
import static hr.fer.zemris.nenr.datasetfactory.Gesture.*;

/**
 * This class implements feature extraction from points generated by
 * dragging the mouse over the canvas.
 * <p>
 * The raw data (x and y coordinates of the points) is scaled and centered.
 * In the end, M representative points are chosen so as to have a fixed
 * number of features for each gesture.
 * <p>
 * An {@link FeatureExtractor#export() export} method is provided that writes the features to a file, each
 * gesture's features in their own line.
 * 
 * @author Ivan Skorupan
 */
public class FeatureExtractor {
	
	/**
	 * List of gestures drawn by the user.
	 */
	private List<Gesture> gestures = new ArrayList<>();
	
	/**
	 * Number of gesture representative points to be taken into the dataset.
	 */
	private int M = 30;
	
	/**
	 * Path to the file to which the features will be exported.
	 */
	private Path datasetFilePath;
	
	/**
	 * Constructs a new {@link FeatureExtractor} object and initializes
	 * it with given parameters.
	 * 
	 * @param m - number of representative points to take
	 * @param datasetFilePath - path to export file
	 */
	public FeatureExtractor(Path datasetFilePath) {
		this.datasetFilePath = datasetFilePath;
	}

	/**
	 * Extracts features from all gestures and exports them into a file.
	 */
	public void export() {
		List<String> linesToWrite = new ArrayList<>();
		
		for (Gesture gesture : gestures) {
			List<Point> points = gesture.getPoints();
			List<DoublePoint> scaled = new ArrayList<>();
			
			DoublePoint tC = centroid(points);
			for (Point point : points)
				scaled.add(new DoublePoint(point.x - tC.getX(), point.y - tC.getY()));
			
			double m = maxCoordinateDistanceFromZero(scaled);
			for (DoublePoint point : scaled) {
				point.setX(point.getX() / m);
				point.setY(point.getY() / m);
			}
			
			List<DoublePoint> samplePoints = sampleGesture(scaled);
			linesToWrite.add(gesture.featureString(samplePoints));
		}
		
		try {
			Files.write(datasetFilePath, linesToWrite);
		} catch (IOException e) {
			System.err.println("There was an error while writing the dataset to a file.");
			e.printStackTrace();
		}
		
		gestures.clear();
		System.out.println("Export complete.");
	}
	
	public Matrix getSample(Gesture gesture) {
		List<Point> points = gesture.getPoints();
		List<DoublePoint> scaled = new ArrayList<>();
		
		DoublePoint tC = centroid(points);
		for (Point point : points)
			scaled.add(new DoublePoint(point.x - tC.getX(), point.y - tC.getY()));
		
		double m = maxCoordinateDistanceFromZero(scaled);
		for (DoublePoint point : scaled) {
			point.setX(point.getX() / m);
			point.setY(point.getY() / m);
		}
		
		List<DoublePoint> samplePoints = sampleGesture(scaled);
		Matrix sample = new Matrix(1, samplePoints.size() * 2);
		
		for (int i = 0; i < samplePoints.size(); i++) {
			DoublePoint point = samplePoints.get(i);
			sample.set(0, i, point.getX());
			sample.set(0, i + 1, point.getY());
		}
		
		return sample;
	}
	
	/**
	 * Takes a fraction of the points from <code>scaled</code> that best represent
	 * the gesture being processed.
	 * 
	 * @param scaled - list of scaled and centered points that represent the currently processed gesture
	 * @return a sample of <code>scaled</code>
	 */
	private List<DoublePoint> sampleGesture(List<DoublePoint> scaled) {
		List<DoublePoint> samplePoints = new ArrayList<>();
		double gestureLength = gestureLength(scaled);
		DoublePoint firstPoint = scaled.get(0);
		
		for (int i = 0; i < M; i++) {
			double targetDistance = i * gestureLength / (M - 1);
			double bestDistance = distance(firstPoint, scaled.get(0));
			int bestIndex = 0;
			
			for (int j = 1; j < scaled.size(); j++) {
				double distance = distance(firstPoint, scaled.get(j));
				if (abs(targetDistance - distance) < abs(targetDistance - bestDistance)) {
					bestDistance = distance;
					bestIndex = j;
				}
			}
			
			samplePoints.add(scaled.get(bestIndex));
		}
		
		return samplePoints;
	}
	
	/**
	 * Finds the coordinate (x or y) from <code>points</code> that's farthest
	 * from zero.
	 * 
	 * @param points - list of points whose coordinated to analyze
	 * @return absolute value of the coordinate farthest from zero
	 */
	private double maxCoordinateDistanceFromZero(List<DoublePoint> points) {
		double mx = abs(points.get(0).getX());
		double my = abs(points.get(0).getY());
		
		for (int i = 1; i < points.size(); i++) {
			double newX = abs(points.get(i).getX());
			double newY = abs(points.get(i).getY());
			
			if (newX > mx) mx = newX;
			if (newY > my) my = newY;
		}
		
		return max(mx, my);
	}
	
	/**
	 * Adds a new gesture to this feature extractor for later processing.
	 * 
	 * @param gesture - a gesture to add to this feature extractor
	 */
	public void addGesture(Gesture gesture) {
		gestures.add(gesture);
		System.out.println("Gestures collected: " + gestures.size());
	}
	
	/**
	 * Returns the gesture at the specified <code>index</code> in the list.
	 * 
	 * @param index - index of gesture to return
	 * @return gesture at the specified <code>index</code>
	 */
	public Gesture getGesture(int index) {
		return gestures.get(index);
	}

	public List<Gesture> getGestures() {
		return gestures;
	}

	public void setGestures(List<Gesture> gestures) {
		this.gestures = gestures;
	}
	
}
